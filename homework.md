# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?
In console.rb, starting lines 6, 15 and 24.

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
Lines 18 to 31(?) of property.rb.

Q3. In console.rb, which lines modify the database?
4, 13, 22, 31, 33

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
We want it to be handled by psql to ensure uniqueness. We get it back from the database and it is 'written to' (bad terminology?) the @id instance variable for the Property object in line 32 of property.rb.

Q5. Where and how do we assign the property id (that is generated by the database) to the ruby object?
See response to Q4. The part of the SQL code in line 29 of property.rb "RETURNING id" ensures that we get a return from psql. The SQL code is executed on line 32 of property.rb. The return will be in the form of an array of hashes (in this case an array with a single element). We reference the hash using the index 0 ([0]) and chain this with ['id'] to ensure we are looking at the value for the 'id' key. I would have thought this would be a string though. Where is it converted to an integer?

Q6. Why do we put a guard (an ‘if’ clause) on the @id attribute in the constructor?
When we call Property.all function we are getting data from the database and creating Propertry objects based on the data. In this case we have an id value. But when we instantiate a Property object (e.g. in console.rb, starting lines 6, 15 and 24) we don't want to define the id as we want psql to do this.

Q7. Why are some of the CRUD actions represented by instance methods, and others, class methods?
If the method relates to a single instance (delete(one row), save, update) then they are instance methods. But if they relate to all of the instances of the class ((retrieve/create objects for) all, delete_all or searches) then they are class methods.

Q8. What type of data structure is returned by db.exec() and db.exec_prepared(), and how do we index into it to pull out a desired attribute?
An array of hashes. If we are only expecting a single row to be returned we would use index 0 [0] to index the first (and only?) hash. We can then access individual attributes using the key for the attribute to get the value for that attribute e.g. for id, ["id"].

Q9. Why do we use prepared statements when performing database operations?
Google tells me it protects against SQL injection attacks.
There also appears to be some performance benefits for the database server but this appears to be limited if you are only querying the database ad hoc.

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the Property class.

Q10. What do they take in as their arguments?
they take in an attribute (either id or address). These can either be input directly as the arguement in the function call or a getter function can be used on a specific Property object.

Q11. What are their return values?
The 'find_by_address' method returns a single instance of the Property class.

As written (with commented out code, lines 82 & 83 of property.rb) the 'find_by_id' returns the raw data from psql which is the array of hashes (with a single element in the array). If the commented out lines were reinstated and line 84 was changed to return found_property, an instance of the Property class would be returned.
